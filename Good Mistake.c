#pragma config(Sensor, S1, TIR, sensorI2CCustom)
#pragma config(Sensor, S2,     sensorDx,       sensorEV3_Color)
#pragma config(Sensor, S3,     sensor0,        sensorEV3_Color)
#pragma config(Sensor, S4,     sensorSx,       sensorEV3_Color)
#pragma config(Motor,  motorA,          motorDx,       tmotorEV3_Large, PIDControl, driveRight, encoder)
#pragma config(Motor,  motorB,          braccio,       tmotorEV3_Medium, PIDControl, encoder)
#pragma config(Motor,  motorD,          motorSx,       tmotorEV3_Large, PIDControl, driveLeft, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

bool neroSX;
bool lastBiancoSx;
bool lastBiancoDx;
int mode;
int error;
int p_value;
int i_value;
int d_value;
int PID;
int error_prec;
int color0;
long redValueDx;
long greenValueDx;
long blueValueDx;
long redValueCC;
long greenValueCC;
long blueValueCC;
long redValueSx;
long greenValueSx;
long blueValueSx;

#define ARDUINO_ADDRESS 	0x14
#define ARDUINO_PORT 			S1
#define BUFFER_LENGTH			32

#define TIME_OUT	BUFFER_LENGTH + 20

ubyte BufferTx[BUFFER_LENGTH + 3];
ubyte BufferRx[BUFFER_LENGTH];
byte b1;
bool bt;
bool finecorsaDx;
bool finecorsaSx;
byte distanzaDavanti;
byte distanzaDietro;
byte distanzaSx;
byte distanzaDx;

#define Max_Timing 2000
#define REFLECTED_BLACK 10
#define redOnWhiteDx  59
#define redOnWhiteSx  65
#define redOnBlackDx  6
#define redOnBlackSx  5
#define blueOnSilver  100

int distance;

const float kP = 2;//era 2 e andava bene
const float kI = 0;
const float kD = 1.4;

float GAIN=(float)(redOnWhiteDx-redOnBlackDx)/(redOnWhiteSx-redOnBlackSx);

#include "function.h"

task update(){
	while(1){
		sendI2CMsg(ARDUINO_PORT, &BufferTx[0], 10);
		for (int bCounter = 0; (bCounter < TIME_OUT) && (nI2CStatus[ARDUINO_PORT] != 0); bCounter++) wait1Msec(1);
		memset((byte *)BufferRx, 0xFF, sizeof(BufferRx)); //punta un po' di memoria per il buffer di ritorno
		readI2CReply(ARDUINO_PORT, &BufferRx[0], 7);
		bt = (bool)BufferRx[0];
		finecorsaDx = (bool)BufferRx[1];
		finecorsaSx = (bool)BufferRx[2];
		distanzaDavanti = BufferRx[3];
		distanzaDietro = BufferRx[4];
		distanzaSx = BufferRx[5];
		distanzaDx = BufferRx[6];
		getColorRGB(sensor0, redValueCC, greenValueCC, blueValueCC); /*Acquisizione dei valori dei canali rgb nelle variabili*/
		getColorRGB(sensorDx, redValueDx, greenValueDx, blueValueDx); /*Acquisizione dei valori dei canali rgb nelle variabili*/
		getColorRGB(sensorSx, redValueSx, greenValueSx, blueValueSx);
		error=(int)(redValueDx-redValueSx*1.1); //calcolo l'errore e moltiplico il canale sx per un guadagno*/
		p_value = (int)(error * kP); //calcolo il parametro proporzionale del pid
		//i_value = 0;
		d_value = (int)(error- error_prec) * kD;
		PID = p_value + i_value + d_value;
		if(blueValueDx>blueOnSilver && blueValueSx>blueOnSilver){ // se entrambi vedono l'argento
			mode=1; //modalità raccogli palline
		}
		if(error<-5 || error>5 || controlloNeroCC()) { //se l'errore è prossimo allo zero per un tempo
			clearTimer(T1);
		}
		if(time1[T1]>Max_Timing){ //se è passato un tempo maggiore di quello prefissato per cui il robot è rimasto con un errore costante allora
			//inizio procedura ricerca linea
			mode=2;
		}
		//if(controlloAlzatoCC()&&controlloAlzatoDx()&&controlloAlzatoSx()) {
		//	muori();
		//}
		if(bt==true){
			mode=-1;
		} else {
			mode=0;
		}
		error_prec=error;
	}
}



/////////////////////////PROVARE NUOVA FUNZIONE MUOVI
task main() {
	b1=0xF;
	BufferTx[0] = 5+2; //lunghezza byte + 2
	BufferTx[1] = ARDUINO_ADDRESS; //Indirizzo arduino
	BufferTx[2] = 0; // cksum
	BufferTx[3] = b1;
	BufferTx[4] = b1;
	clearTimer(T1);
	startTask(update);
	PID=0;
	mode=0;
	distance=10;
	while (true){
		if(mode==-1){
			muovi(0,0);
			delay(1);
		} else if(mode==0){//Segui linea

			if(distance<5) {
				evitaOstacolo();
			}
			if(controlloVerdeDx()) { //controlla se vede il verde a dx
				muovi(20,20); //va avanti per 250 ms
				delay(250);
				//muovi(20,20,250);
				if(controlloVerdeDx() && controlloVerdeSx()){ //controlla se c'è doppio verde
					doppioVerde(); // se c'è lo fa
					} else {
						muovi(20,20);
				delay(350);
					verdeDx(); //altrimenti fa verde a dx
				}
			}
			if(controlloVerdeSx()) { //controlla se vede il verde a sx
				muovi(20,20);
				delay(250);
				//muovi(20,20,250);
				if(controlloVerdeDx() && controlloVerdeSx()){
					doppioVerde();
					} else {
						muovi(20,20);
				delay(350);
					verdeSx(); //verdeDx
				}
			}
			if(controlloBiancoSx() || controlloBiancoDx()) {
				muovi(35 + PID, 35 - PID);
				if(error>25){
					while(error<-1){
						muovi(30,-15);
					}
				}
				if(error<-25){
					while(error>1){
						muovi(-15,30);
					}
				}
			}
			if(controlloNeroSx() && controlloBiancoDx()) { //se sx nero e dx bianco
				neroSX=true;
			}
			if(controlloBiancoSx() && controlloNeroDx()) { //se sx bianco e sx nero
				neroSX=false;
			}
			if(controlloBiancoSx() || controlloVerdeSx()) { //se sx bianco o sx verde
				lastBiancoSx=true;
			} else {
				lastBiancoSx=false;
			}
			if(controlloBiancoDx()|| controlloVerdeDx()) {
				lastBiancoDx=true;
			} else {
				lastBiancoDx=false;
			}
			if(controlloNeroSx() && controlloNeroDx() && neroSX==true) { //nero sx && nero dx e ultimo nero
				repeatUntil(controlloBiancoSx() || controlloBiancoDx()) {
					muovi(20,20);
				}
				repeatUntil(griginoDx()) {
					if(controlloVerdeSx() || controlloVerdeDx()) {
						muovi(30,30);
						delay(200);
						//muovi(30,30,200);

						} else {
						muovi(30,-20);
					}
				}
			}
			if(controlloNeroSx() && controlloNeroDx() && neroSX==false){ //neroSx e nero dx e non nerosx
				repeatUntil(controlloBiancoSx() || controlloBiancoDx()){ //finchè non vede il bianco da una delle due parti
					muovi(20,20); //va avanti
				}
				repeatUntil(griginoSx()) {
					if(controlloVerdeSx() || controlloVerdeDx()) {
						muovi(30,30);
						delay(200);
						//muovi(30,30,200);

					} else {
						muovi(-20,30);
					}
				}
			}
			if(controlloNeroCC() && griginoSx() && griginoDx()) {
				repeatUntil(controlloBiancoSx() && controlloBiancoDx()) { //rendere smart
					muovi(20,20);
				}
			}
			if(controlloNeroCC() && griginoDx()) { //se davanti nero dx grigio
				repeatUntil(controlloBiancoDx()) { //what
					muovi(20,20);
				}
				/*
				while(!controlloBiancoDx()){
					muovi(20,20);
				}
				*/
			}
			if(controlloNeroCC() && griginoSx()){ //se davanti nero e grigio sx
				repeatUntil(controlloBiancoSx()) { //sicuro?
					muovi(20,20);
				}
				/*
				while(!controlloBiancoSx()) {
					muovi(20,20);
				}
				*/
			}

				//if(controlloVerdeCC()){
				//repeatUntil(!controlloVerdeCC())
				//{
				//muovi(-30,30);
				//}
				//if(controlloBiancoCC())
				//{
				//		repeatUntil(controlloNeroCC())
				//{
				//muovi(30,-30);
				//}

				//}

			//}

		} else if (mode==1) { //arena
			muori();
		} else if (mode==2) { //richiappa la linea
			while(!griginoSx() && !griginoDx()){
				muovi(-30,-30);
			}
			if(griginoSx()) { //se lo ha visto a sx
				while(controlloNeroCC()){
					muovi(40,-10);
				}
				mode=0;
			} else {
				while(controlloNeroCC()){
					muovi(-10,40);
				}
				mode=0;
				mode=0;
			}

			}



	}
}
